// =============================================================================
// ZenStack Schema - Bookmarks Challenge
// =============================================================================
// This schema uses ZenStack to define both the database models AND access policies.
// ZenStack extends Prisma with @@allow and @@deny rules that enforce authorization
// at the data layer.
//
// YOUR TASK: Extend this schema with Collection and Bookmark models.
// See the README for requirements on share modes and access policies.
// =============================================================================

generator client {
  provider = "prisma-client-js"
  output   = "../../../node_modules/.prisma/client"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// =============================================================================
// PROVIDED: User Model
// =============================================================================
// This model is provided for you. Do not modify it.

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  createdAt DateTime @default(now())

  // User has zero or more collections
  collections Collection[]

  // Access policy: Users are readable by anyone (for displaying owner info)
  @@allow('read', true)
}

// =============================================================================
// PROVIDED: ShareMode Enum
// =============================================================================
// Use this enum for your Collection model's shareMode field.

enum ShareMode {
  PRIVATE           // Only owner can view
  LINK_ACCESS       // Anyone with the URL can view (read-only)
  PASSWORD_PROTECTED // Requires password to view
}

// =============================================================================
// TODO: Implement Collection Model
// =============================================================================
// Requirements:
// - id: String primary key with cuid() default
// - name: String (required)
// - description: String (optional)
// - slug: String (unique, for shareable URLs) - use cuid() default
// - shareMode: ShareMode enum, default to PRIVATE
// - sharePassword: String (optional) - use @omit to never expose to client
// - owner relation to User
// - bookmarks relation to Bookmark[]
// - createdAt/updatedAt timestamps
//
// Access Policies:
// - create: Only authenticated users can create
// - read: Owner can always read, others can read if shareMode != PRIVATE
// - update/delete: Only owner can modify
//
model Collection {
  id String @id @default(cuid())
  name String
  description String?
  slug String @unique @default(cuid())
  shareMode ShareMode @default(PRIVATE)
  
  // @password is necessary for ensuring the string is hashed correctly, ZenStack uses bcryptjs under the hood.
  sharePassword String? @password @omit

  // The owner of the collection, references User.id
  ownerId String
  owner User @relation(fields: [ownerId], references: [id])

  // Collection has 0 or more bookmarks
  bookmarks Bookmark[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // acls per the policies above. The read policy here is critical to enforcing Share Controls
  // `When a collection is changed to PRIVATE, all users except the owner immediately lose access`
  // The Policy Check for shareMode != PRIVATE is continuously evaluated at runtime.
  // Bookmark inherits from it's collections rules so everything applies simulatenously to Bookmarks
  
  @@allow('create', auth() != null)
  @@allow('read', auth() == owner || shareMode != PRIVATE)
  @@allow('update,delete', auth() == owner)
  
}

// =============================================================================
// Implement Bookmark Model
// =============================================================================
// Requirements:
// - id: String primary key with cuid() default
// - title: String (required)
// - url: String (required)
// - description: String (optional)
// - tags: String[] (optional, default empty array) - Note: SQLite doesn't support
//   arrays natively, so you may need to store as JSON string or use a separate Tag model
// - collection relation to Collection (with cascade delete)
// - createdAt/updatedAt timestamps
//
// Access Policies:
// - Inherit from parent collection:
//   - create: Only collection owner can add bookmarks
//   - read: Same as collection read policy
//   - update/delete: Only collection owner can modify
//
model Bookmark {

  id String @id @default(cuid())
  title String
  url String
  description String?
  tags Tag[]

  collectionId String
  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // acls per policies above, inheriting from the parent collection
  // Check if the user has update rights on the parent.
  @@allow('create,update,delete', check(collection,'update'))
  // Check if the user has read rights on the parent
  @@allow('read',check(collection,'read'))
  
}

// Tag model implementation
model Tag {
  id String @id @default(cuid())
  name String
  
  // Tag is owned by bookmark
  bookmarkId String
  bookmark Bookmark @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)
  
  // acl's - if you can update a bookmark you can add / remove a tag
  @@allow('create,update,delete',check(bookmark,'update'))
  @@allow('read', check(bookmark,'read'))

}
